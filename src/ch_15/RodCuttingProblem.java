package ch_15;

public class RodCuttingProblem {
    /*
    Problem Statement :-
        Given a rod of length n inches and a table of prices p(i) for i = 1, 2,...n. Determine the maximum revenue r(n) obtainable by cutting up
        the rod and selling the pieces. Note that if the price p(n) for a rod of length n is large enough, an optimal solution may require no
        cutting at all.
     */

    /*
    Solution :-
        The problem is to find the maximum revenue which can be generated from a rod of length n inches by cutting it into pieces of integral length.
        Suppose that the maximum revenue is generated by cutting the rod into k pieces. Then,
        1 <= k <= n where 1 corresponds to no cut at all and n corresponds to cutting the rod into n pieces of 1 inch each.
        Also, since we are assuming that this is providing the max revenue so, p(0) + p(1) + p(2) + ... + p(k) will be the maximum revenue for rod
        of length n.
     */

    /*
    Approach 1:- Naive recursion
        Suppose r(i) is the max revenue from a rod of length i. So for a rod of given length n r(n) can be viewed as
        r(n) = max(p(n), r(1) + r(n-1), r(2) + r(n-2), r(3) + r(n-3),...., r(n-1) + r(1)) which corresponds to
        p(n) => when we cut the rod uncut
        r(1) + r(n-1) => when we make the first cut at 1 inch from the left end of the rod
        r(2) + r(n-2) => when we make the first cut at 2 inch from the left end of the rod
        and so on...
        In the above case, the equation of our solution would be
        r(n) = max(p(n), r(1) + r(n-1), r(2) + r(n-2),..., r(n-1) + r(1))
        in above case there will be two calls for each r(n) case. Can we do better?

        Another way to think about it is lets consider that if we cut a rod from left end, then we won't cut the left portion and
        sell it as it is. However, we can cut the remaining right portion of the rod thus effectively reducing the size of the problem.
        so, our previous equation would reduce to
        r(n) = max(p(n), p(1) + r(n-1), p(2) + r(n-2), p(3) + r(n-3), ... , p(n-1) + r(1))
        lets try to code this solution
     */


    // Price is the array that contain the price of rod of particular length. For eg:- price[4] = 5 means on selling the rod with length 4 inch
    // without cutting will give us 5 rs
    public static int rodCuttingNaiveRecursion(int[] price, int size){
        if (size == 0)
            return 0; // A rod with length 0 won't generate any revenue. Hence 0
        int maxRevenue = 0;
//        System.out.println("method called for size " + size);
        for (int i = 1; i <= size; i++){ // Here we are checking for each left cut
                maxRevenue = max(maxRevenue, price[i] + rodCuttingNaiveRecursion(price, size - i));
        }
        return maxRevenue;
    }

    private static int max(int a, int b){
        return a > b ? a : b;
    }

    /*
    Q. How the above solution is working ?
    A. The above solution works on the principle of mathematical induction. Suppose we have a rod of length 1 inch then there is no other
     way to sell the rod other than selling the rod as it is as it can't be cut further. Now suppose we have a method rodCuttuingNaiveRecursion
     which is giving us the maximum revenue for any size(How?). Here it is :-
     for length == 1 maxRevenue will be max(p[1] + rodCuttingNaiveRecursion[1-1]). Now rodCutting of 0 will be 0(base case of the method). So it
     will reduce to p[1] which we already found logically. So now we have rodCutting of 1. Now suppose the length is greater than 1 lets say 2.
     then the solution would be the for loop with max.
     Note:- In this explanation we are denoting the rodCuttingNaiveRecurion method of size i by r(i)
      Initially the maxRevenue would be 0. So for the first iteration (i.e for  i = 1):
     max(0, p[1] + r(2-1)) -> r(1) we already solved. So, maxRevenue will be updated with p[1] + r(1) (since that will be a positive value(assuming we get some profit on selling the rod)
     for second iteration (i.e for i = 2)
     max(maxRevenue(calculated previously in first iteration), p[2] + r(2-2)) we already know that r(0) = 0 (base case) so this will compare
     the case when the rod is cut into two pieces vs when the rod is sold it is.
     after this iteration the loop will terminate and r(2) will be returned
     Similarly, we can go on for any given size n.


     */


    /*
    The above solution works but the problem is it is very slow as same problem is solved again and again.
    also for each increasing input the time taken by the solution increases drastically
    Here Dynamic Programming comes into picture
    The idea of dynamic programming is to save the solution of the smaller subproblem once it is solved so that the solution can be reused
    if it comes into some other subproblem. This follows that for the dynamic programming to be a feasible solution, the problem should be
    such that it has overlapping subproblems.
    For eg:- in rod cutting problem scenerio r(10) and r(9) both will have r(8), r(7), r(6), ... as their subproblem.
    this is called overlapping subproblem property.
     */

    // Applying dynamic programming approach to previous naive recursive solution
    // The only problem with the previous solution is that it was solving same problem many times. To avoid that we will
    // store the solution of the subproblem when we solve it firs time and from the next time we will use that solution.
    // For creating that storage lets create one array r of length n+1(0, 1, 2,...n) and store the value or revenue r(i) in the index i of r i.e r[i] = r(i)
    // Applying this storage element to the simple naive recursive solution is called top down approach of dynamic programming with memoization
    // Memoization :- Creating a memo of problem size and its solution.

    public static int rodCuttingTopDownWithMemoization(int price[], int size){
        int [] r = new int[size + 1];
        for (int i = 0; i < size+1; i++)
            r[i] = Integer.MIN_VALUE;  // Initializing the revenue array with minimum value
        return topDownRodCuttingHelper(price, size, r);
    }

    private static int topDownRodCuttingHelper(int[] price, int size, int[] r){
        if (size == 0)
            return 0;
        if (r[size] > Integer.MIN_VALUE)
            return r[size];
        int maxRevenue = Integer.MIN_VALUE;
//        System.out.println("method called for size " +size);  // To view the difference b/w the DP and naive solution uncomment this line
        // and run both the solution. In DP approach for each size there will be only one line printed but for naive it will be many times depending on the size of problem
        for (int i = 1; i <= size; i++)
            maxRevenue = max(maxRevenue, price[i] + topDownRodCuttingHelper(price, size -i, r));
        r[size] = maxRevenue;
        return maxRevenue;
    }

}
